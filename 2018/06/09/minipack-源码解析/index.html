<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> minipack 源码解析 · 熊乐写字的地方</title><meta name="description" content="minipack 源码解析 - tracyxiong1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://tracyxiong1.github.io/atom.xml" title="熊乐写字的地方"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tracyxiong1" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">minipack 源码解析</h1><div class="post-info">Jun 9, 2018</div><div class="post-content"><h1 id="minipack-是什么"><a href="#minipack-是什么" class="headerlink" title="minipack 是什么"></a>minipack 是什么</h1><blockquote>
<p> A simplified example of a modern module bundler written in JavaScript</p>
</blockquote>
<p>正如 <a href="https://github.com/ronami/minipack" target="_blank" rel="noopener">github</a> 介绍，这是一个用 JavaScript 编写的现代模块构建工具的简化示例。</p>
<p>作为一名 FE, 平时可能会使用 Webpack/Browserify/Rollup/Parcel 等构建工具。了解这些构建工具的工作原理可以帮助我们更好地决定编写代码的方式，所以了解他们的工作原理还是很有必要的。</p>
<p>本文将围绕 minipack 的源码来分析如何实现一个 module bundlers.</p>
<a id="more"></a>
<h2 id="module-bundlers"><a href="#module-bundlers" class="headerlink" title="module bundlers"></a>module bundlers</h2><p>module bundlers 将小块代码编译成更大和更复杂的代码，让其运行在 Web 浏览器中。 它拥有入口文件的概念，我们让 module bundlers 知道哪个文件是我们应用程序的入口文件，然后让 module bundlers 从该文件开始，并去尝试理解它依赖哪些文件，然后它会尝试了解这些文件的依赖关系，直到它发现应用程序中的每个模块，以及它们如何相互依赖，最后构成 dependenciesGraph(依赖图).</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>代码主要有三个重要方法</p>
<h3 id="createAsset"><a href="#createAsset" class="headerlink" title="createAsset"></a>createAsset</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法接受文件路径, 读取内容并提取它的依赖关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以字符串形式读取文件的内容</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 babylon 转换我们的原始代码，转换之后生成抽象语法树(AST)</span></span><br><span class="line">  <span class="comment">// babylon 的介绍可以参考 https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-babylon</span></span><br><span class="line">  <span class="comment">// 如果对 AST 不太了解，可以通过 https://astexplorer.net/ 查看生成的 AST 代码是怎样的</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当我们解析完以后，我们就可以提取当前文件中的 dependencies</span></span><br><span class="line">  <span class="comment">// dependencies 翻译为依赖，也就是我们文件中所有的 `import xxxx from xxxx`</span></span><br><span class="line">  <span class="comment">// 我们将这些依赖都放在 dependencies 的数组里面，这个数组将保存这个模块依赖的模块的相对路径</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 babel-traverse 遍历 AST，babel-traverse 的介绍可以参考 https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-babel-traverse</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 当遍历到类型为 `ImportDeclaration` 的 AST 节点，其实就是我们的 `import xxx from xxx.js`</span></span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123;node&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将匹配到的模块路径 push 到 dependencies</span></span><br><span class="line">      dependencies.push(node.source.value);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递增简单计数器为此模块分配唯一标识符</span></span><br><span class="line">  <span class="keyword">const</span> id = ID++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// es6 module 以及 es6 语法无法兼容所有浏览器</span></span><br><span class="line">  <span class="comment">// 为了确保 bundle 能在所有的浏览器种运行，使用 babel 进行编译，转换成 CommonJS 代码</span></span><br><span class="line">  <span class="comment">// 使用 babel-preset-env 确定需要支持的浏览器</span></span><br><span class="line">  <span class="keyword">const</span> &#123;code&#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后将模块导出</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id,</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createGraph"><a href="#createGraph" class="headerlink" title="createGraph"></a>createGraph</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法接收入口文件的文件路径，获取整个应用程序的每个模块的依赖关系，可以把它抽象理解为依赖图</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先解析入口文件，获取入口模块的信息</span></span><br><span class="line">  <span class="keyword">const</span> mainAsset = createAsset(entry);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [mainAsset];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用一个`for ... of`循环遍历 queue</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">	<span class="comment">// 子模块的依赖关系</span></span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历依赖的模块</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 转换成绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析依赖</span></span><br><span class="line">      <span class="keyword">const</span> child = createAsset(absolutePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 供后期 require $&#123;id&#125; 使用</span></span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将解析的依赖 push 到 queue 中</span></span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后将 queue 返回，包含了目标应用中每个 module 的信息</span></span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法将 graph 加工成浏览器中可执行代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在我们到达该函数的主体之前,我们将构建一个作为该函数的参数的对象</span></span><br><span class="line">  <span class="comment">// 请注意, 我们构建的这个字符串被两个花括号 (&#123;&#125;) 包裹, 因此对于每个模块,</span></span><br><span class="line">  <span class="comment">// 我们添加一个这种格式的字符串: `key: value,`</span></span><br><span class="line">  graph.forEach(<span class="function"><span class="params">mod</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  图表中的每个模块在这个对象中都有一个`entry`. 我们使用`模块的id`作为`key`和一个数组作为`value` (用数组因为我们在每个模块中有2个值)</span></span><br><span class="line">    <span class="comment">// 第一个值是用函数包装的每个模块的代码. 这是因为模块应该被 限定范围: 在一个模块中定义变量不会影响 其他模块 或 全局范围</span></span><br><span class="line">    <span class="comment">// 我们的模块在我们将它们`转换&#123;被 babel 转译&#125;`后, 使用`commonjs`模块系统: 他们期望一个`require`, 一个`module`和`exports`对象可用. 那些在浏览器中通常不可用,所以我们将它们实现并将它们注入到函数包装中</span></span><br><span class="line">    <span class="comment">// 对于第二个值,我们用`stringify`解析模块及其依赖之间的关系(也就是上文的asset.mapping). 解析后的对象看起来像这样: `&#123;'./relative/path': 1&#125;`</span></span><br><span class="line">    <span class="comment">// 这是因为我们模块的被转换后会通过相对路径来调用`require()`. 当调用这个函数时,我们应该能够知道依赖图中的哪个模块对应于该模块的相对路径</span></span><br><span class="line">    modules += <span class="string">`<span class="subst">$&#123;mod.id&#125;</span>: [</span></span><br><span class="line"><span class="string">      function (require, module, exports) &#123; <span class="subst">$&#123;mod.code&#125;</span> &#125;,</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(mod.mapping)&#125;</span>,</span></span><br><span class="line"><span class="string">    ],`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一段代码实际上才是模块引入的核心逻辑</span></span><br><span class="line">  <span class="comment">// 我们制造一个顶层的 require 函数，这个函数接收一个 id 作为值，并且返回一个全新的 module 对象</span></span><br><span class="line">  <span class="comment">// 我们倒入我们刚刚制作好的模块，给他加上 &#123;&#125;，使其成为 &#123;1:[...],2:[...]&#125; 这样一个完整的形式</span></span><br><span class="line">  <span class="comment">// 然后塞入我们的立即执行函数中(function(modules) &#123;...&#125;)()</span></span><br><span class="line">  <span class="comment">// 在 (function(modules) &#123;...&#125;)() 中，我们先调用 require(0)</span></span><br><span class="line">  <span class="comment">// 理由很简单，因为我们的主模块永远是排在第一位的</span></span><br><span class="line">  <span class="comment">// 紧接着，在我们的 require 函数中，我们拿到外部传进来的 modules，利用我们一直在说的全局数字 id 获取我们的模块</span></span><br><span class="line">  <span class="comment">// 每个模块获取出来的就是一个二维元组</span></span><br><span class="line">  <span class="comment">// 然后，我们要制造一个 `子require`</span></span><br><span class="line">  <span class="comment">// 这么做的原因是我们在文件中使用 require 时，我们一般 require 的是地址，而顶层的 require 函数参数时 id</span></span><br><span class="line">  <span class="comment">// 不要担心，我们之前的 idMapping 在这里就用上了，通过用户 require 进来的地址，在 idMapping 中找到 id</span></span><br><span class="line">  <span class="comment">// 然后递归调用 require(id)，就能够实现模块的自动倒入了</span></span><br><span class="line">  <span class="comment">// 接下来制造一个 const newModule = &#123;exports: &#123;&#125;&#125;;</span></span><br><span class="line">  <span class="comment">// 运行我们的函数 fn(childRequire, newModule, newModule.exports);，将应该丢进去的丢进去</span></span><br><span class="line">  <span class="comment">// 最后 return newModule.exports 这个模块的 exports 对象</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function(modules) &#123;</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        function localRequire(name) &#123;</span></span><br><span class="line"><span class="string">          return require(mapping[name]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        const module = &#123; exports : &#123;&#125; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return module.exports;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      require(0);</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回过头来看，思路还是比较清晰的，主要分为两步：</p>
<ol>
<li>通过 babel 以及 babel 插件，分析、收集依赖，得到整个程序的依赖图</li>
<li>实现一个 loader, 用于 require module</li>
</ol>
<p>这是一个简化的构建工具设计流程，例子中还有一些问题尚未处理，比如只支持 es6 模块收集，无法兼容 CommonJS/CMD/AMD 模块; 模块引用路径必须写后缀名等问题。需要优化的地方还有很多，感兴趣的同学可以 fork 该项目完善。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/chinanf-boy/minipack-explain/blob/master/src/minipack.js" target="_blank" rel="noopener">minipack-explain</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/30/记一次微信小程序开发过程/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://tracyxiong1.github.io">tracyxiong1</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>